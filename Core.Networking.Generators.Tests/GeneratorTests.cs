using System.Reflection;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using QuantumCore.Core.Networking;
using QuantumCore.Networking;
using Xunit;

namespace Core.Networking.Generators.Tests;

public class GeneratorTests
{
    private static Compilation CreateCompilation(params string[] source)
        => CSharpCompilation.Create("compilation",
            source.Select(x => CSharpSyntaxTree.ParseText(x)).ToArray(),
            new[]
            {
                MetadataReference.CreateFromFile(typeof(GeneratorTests).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(PacketAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(AppDomain.CurrentDomain.GetAssemblies()
                    .First(x => x.GetName().Name == "System.Runtime").Location),
            },
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    [Fact]
    public void RecordStruct()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time, uint Delta);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Record()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, uint Time, uint Delta);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Record_WithEnumAsByte()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

public enum HandshakeType : byte {
    
}

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, HandshakeType Type);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            bytes[offset + 5] = (byte)this.Type;
        }

        public ushort GetSize() {
            return 6;
        }
    }
}");
    }

    [Fact]
    public void Record_WithEnumAsInt()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

public enum HandshakeType : int {
    
}

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, HandshakeType Type);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes((System.Int32)this.Type).CopyTo(bytes, offset + 5);
        }

        public ushort GetSize() {
            return 9;
        }
    }
}");
    }

    [Fact]
    public void Record_CustomOrder()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time) {
    [Field(0)]
    public uint Size => 15; 
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Size).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Record_WithDynamicString()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, string Message) {
    [Field(1)]
    public uint Size => (uint)Message.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            System.BitConverter.GetBytes(this.Size).CopyTo(bytes, offset + 2);
            System.Text.Encoding.ASCII.GetBytes(this.Message).CopyTo(bytes, offset + 6);
        }

        public ushort GetSize() {
            return (ushort)(6 + this.Message.Length);
        }
    }
}");
    }

    [Fact]
    public void Record_WithDynamicByteArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, byte[] Flags) {
    [Field(1)]
    public uint Size => (uint)Flags.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            System.BitConverter.GetBytes(this.Size).CopyTo(bytes, offset + 2);
            this.Flags.CopyTo(bytes, offset + 6);
        }

        public ushort GetSize() {
            return (ushort)(6 + this.Flags.Length);
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithFixedByteArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type)
{
    public byte[] Flags { get; init; } = new byte[4];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            this.Flags.CopyTo(bytes, offset + 2);
        }

        public ushort GetSize() {
            return 6;
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithFixedUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type)
{
    public ushort[] Flags { get; init; } = new ushort[2];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            System.BitConverter.GetBytes(this.Flags[0]).CopyTo(bytes, offset + 2);
            System.BitConverter.GetBytes(this.Flags[1]).CopyTo(bytes, offset + 4);
        }

        public ushort GetSize() {
            return 6;
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithFixedDynamicStringArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake()
{
    public string[] Names { get; init; } = new string[2];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.Text.Encoding.ASCII.GetBytes(this.Names[0]).CopyTo(bytes, offset + 1);
            System.Text.Encoding.ASCII.GetBytes(this.Names[1]).CopyTo(bytes, offset + 1 + this.Names[0].Length);
        }

        public ushort GetSize() {
            return (ushort)(1 + this.Names[0].Length + this.Names[1].Length);
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithDynamicUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type)
{
    public ushort[] Flags { get; init; }
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            for (var i = 0; i < this.Flags.Length; i++)
            {
                System.BitConverter.GetBytes(this.Flags[i]).CopyTo(bytes, offset + 2 + i * 2);
            }
        }

        public ushort GetSize() {
            return (ushort)(2 + this.Flags.Length * 2);
        }
    }
}");
    }

    [Fact]
    public void Record_WithDynamic_FieldAfter()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, string Message, byte Location) {
    [Field(1)]
    public uint Size => (uint)this.Message.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            System.BitConverter.GetBytes(this.Size).CopyTo(bytes, offset + 2);
            System.Text.Encoding.ASCII.GetBytes(this.Message).CopyTo(bytes, offset + 6);
            bytes[offset + 6 + this.Message.Length] = this.Location;
        }

        public ushort GetSize() {
            return (ushort)(7 + this.Message.Length);
        }
    }
}");
    }

    [Fact]
    public void MultipleTypesPerFile()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time, uint Delta);

[Packet(0xfd, EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCPhase(byte Phase);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(2);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(2);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
        runResult.Results[0].GeneratedSources[1].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record struct GCPhase : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xfd;
            bytes[offset + 1] = this.Phase;
        }

        public ushort GetSize() {
            return 2;
        }
    }
}");
    }

    [Fact]
    public void Struct()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial struct GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial struct GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Class()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Class_WithSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData Sub { get; set; }
}

public class SomeData {
    public uint SomeSubData { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
            System.BitConverter.GetBytes(this.Sub.SomeSubData).CopyTo(bytes, offset + 13);
        }

        public ushort GetSize() {
            return 17;
        }
    }
}");
    }

    [Fact]
    public void RecordWithMembers()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, uint Time) {
    public uint Delta { get; init; }
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
        }

        public ushort GetSize() {
            return 13;
        }
    }
}");
    }

    [Fact]
    public void Class_WithFixedArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData[] Subs { get; set; } = new SomeData[4];
}

public class SomeData {
    public uint SomeSubData { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
            System.BitConverter.GetBytes(this.Subs[0].SomeSubData).CopyTo(bytes, offset + 13);
            System.BitConverter.GetBytes(this.Subs[1].SomeSubData).CopyTo(bytes, offset + 17);
            System.BitConverter.GetBytes(this.Subs[2].SomeSubData).CopyTo(bytes, offset + 21);
            System.BitConverter.GetBytes(this.Subs[3].SomeSubData).CopyTo(bytes, offset + 25);
        }

        public ushort GetSize() {
            return 29;
        }
    }
}");
    }

    [Fact]
    public void Class_WithDynamicArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData[] Subs { get; set; }
}

public class SomeData {
    public uint SomeSubData { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0xff;
            System.BitConverter.GetBytes(this.Handshake).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.Time).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Delta).CopyTo(bytes, offset + 9);
            for (var i = 0; i < this.Subs.Length; i++)
            {
                System.BitConverter.GetBytes(this.Subs[i].SomeSubData).CopyTo(bytes, offset + 13 + i * 4);
            }
        }

        public ushort GetSize() {
            return (ushort)(13 + this.Subs.Length * 4);
        }
    }
}");
    }

    [Fact]
    public void Class_DataAfterFixedUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x88, EDirection.Incoming)]
[PacketGenerator]
public partial class CharacterInfo {
    [Field(0)]
    public uint Vid { get; set; }
    [Field(1, Length = 25)]
    public string Name { get; set; }
    [Field(2, ArrayLength = 4)]
    public ushort[] Parts { get; set; } = new ushort[4];
    [Field(3)]
    public byte Empire { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets {

    public partial class CharacterInfo : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0x88;
            System.BitConverter.GetBytes(this.Vid).CopyTo(bytes, offset + 1);
            System.Text.Encoding.ASCII.GetBytes(this.Name).CopyTo(bytes, offset + 5);
            System.BitConverter.GetBytes(this.Parts[0]).CopyTo(bytes, offset + 5 + this.Name.Length);
            System.BitConverter.GetBytes(this.Parts[1]).CopyTo(bytes, offset + 7 + this.Name.Length);
            System.BitConverter.GetBytes(this.Parts[2]).CopyTo(bytes, offset + 9 + this.Name.Length);
            System.BitConverter.GetBytes(this.Parts[3]).CopyTo(bytes, offset + 11 + this.Name.Length);
            bytes[offset + 13 + this.Name.Length] = this.Empire;
        }

        public ushort GetSize() {
            return (ushort)(14 + this.Name.Length);
        }
    }
}");
    }

    [Fact]
    public void Invalid_PositionDoesNotExist()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Auth.Packets
{
    [Packet(0x07, EDirection.Outgoing)]
    [PacketGenerator]
    public class LoginFailed
    {
        [Field(1, Length = 9)]
        public string Status { get; set; }
    }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out _,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().Be(@"Generator 'SerializerGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'Exception' with message 'Failed to generate code for type [Packet(0x07, EDirection.Outgoing)]
    [PacketGenerator]
    public class LoginFailed
    {
        [Field(1, Length = 9)]
        public string Status { get; set; }
    }. InnerMessage: Field cannot have a higher number (1) than actual fields count 1'");
    }
    
    // TODO sub types

    [Fact]
    public void MultipleFiles()
    {
        const string file1 = @"
using QuantumCore.Core.Networking;
using QuantumCore.Networking;

namespace QuantumCore.Game.Packets;

[Packet(0x20, EDirection.Outgoing)]
[PacketGenerator]
public partial record struct Characters ()
{
    public Character[] CharacterList { get; set; } = new Character[2];
}";
        const string file2 = @"
namespace QuantumCore.Game.Packets;

public record Character(uint Id);";
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new SerializerGenerator());
        var inputCompilation = CreateCompilation(file1, file2);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results.Should().HaveCount(1);
        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using QuantumCore.Networking;

namespace QuantumCore.Game.Packets {

    public partial record struct Characters : IPacketSerializable
    {
        public void Serialize(byte[] bytes, int offset = 0) {
            bytes[offset + 0] = 0x20;
            System.BitConverter.GetBytes(this.CharacterList[0].Id).CopyTo(bytes, offset + 1);
            System.BitConverter.GetBytes(this.CharacterList[1].Id).CopyTo(bytes, offset + 5);
        }

        public ushort GetSize() {
            return 9;
        }
    }
}");

    }

    [Fact]
    public void ReadonlyRefStruct()
    {
        Assert.True(true, "ref structs cannot implement interfaces");
    }
}