using System.Collections.Immutable;
using System.Text;

namespace QuantumCore.Networking;

public class PacketSourceGenerator
{
    private const int MaxBufferSize = 4096;

    public static string GenerateHeader(PacketTypeInfo type)
    {
        var interfaceToInherit = type.IsServerToClient
            ? "IServerToClientPacket"
            : "IClientToServerPacket";
        return $$"""
                 /// <auto-generated/>
                 #pragma warning disable CS8019 // Unnecessary using directive
                 using System.Buffers;
                 using System.IO;
                 using System.Text;

                 namespace {{type.Namespace}};

                 public partial struct {{type.Name}} : {{interfaceToInherit}}
                 {
                 """;
    }

    public static string GenerateFooter(PacketTypeInfo type)
    {
        return "}";
    }

    public static string GenerateWriteHeader(PacketTypeInfo type)
    {
        var rent = type.FixedSize ?? MaxBufferSize;
        return $$"""
                     public void Write(Stream stream)
                     {
                         var buffer = ArrayPool<byte>.Shared.Rent({{rent}});
                         buffer[0] = 0x{{type.Header:X2}};
                 """;
    }

    public static string GenerateWriteFooter(PacketTypeInfo type)
    {
        var sizeString = ""; // TODO
        var size = type.FixedSize.HasValue ? type.FixedSize.Value.ToString() : sizeString;
        return $$"""
                         stream.Write(buffer, 0, {{size}});
                         ArrayPool<byte>.Shared.Return(buffer);
                     }
                 """;
    }

    public static string GenerateLines(ref int index, PacketFieldInfo2 field)
    {
        var sb = new StringBuilder();
        var setters = GetSetters(field, ref index, out var isFullLine);
        foreach (var setter in setters)
        {
            if (isFullLine)
            {
                sb.AppendLine($"        {setter}");
                // index will be set in GetSetters
            }
            else
            {
                sb.AppendLine($"        buffer[{index}] = {setter};");
                index++;
            }
        }

        return sb.ToString();
    }

    public static string Generate(PacketTypeInfo type)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GenerateHeader(type));

        if (type.IsServerToClient)
        {
            sb.AppendLine(GenerateWriteHeader(type));
            var index = 1;
            foreach (var field in type.Fields)
            {
                if (field.ElementSize > 0)
                {
                    sb.AppendLine(GenerateLines(ref index, field));
                }
                else
                {
                    throw new NotImplementedException();
                }
            }

            sb.AppendLine(GenerateWriteFooter(type));
        }

        sb.AppendLine(GenerateFooter(type));
        return sb.ToString();
    }

    private static ImmutableArray<string> GetSetters(PacketFieldInfo2 field, ref int index, out bool isFullLine)
    {
        isFullLine = false;
        if (field.ConstantValue is not null) return [field.ConstantValue.ToString()];

        if (field.IsEnum)
        {
            return
            [
                ..Enumerable.Range(0, field.ElementSize)
                    .Select(x => $"(byte) (({field.ElementTypeFullName}){field.Name} >> {8 * x})")
            ];
        }

        if (field.IsArray)
        {
            if (field.ArrayLength is not null)
            {
                if (field.ElementTypeFullName == typeof(byte).FullName)
                {
                    var str = $"{field.Name}.CopyTo(buffer, {index}, {field.ArrayLength});";
                    isFullLine = true;
                    index += field.ArrayLength.Value;
                    return [str];
                }
            }

            var sb = new StringBuilder();
            sb.AppendLine("for (var i = 0; i < 2; i++)");
            sb.AppendLine("        {");
            for (var i = 0; i < field.ElementSize; i++)
            {
                sb.AppendLine($"            buffer[i * {field.ElementSize} + {i}] = (byte) (Data[i] >> {8 * i});");
            }
            sb.Append("        }");
            isFullLine = true;
            index += field.FieldSize;
            return [sb.ToString()];
        }

        switch (true)
        {
            case true when field.TypeFullName == typeof(string).FullName:
                var str = $"Encoding.ASCII.GetBytes({field.Name}, 0, {field.ElementSize}, buffer, {index});";
                index += field.ElementSize;
                isFullLine = true;
                return [str];
            case true when field.TypeFullName == typeof(bool).FullName:
                return [$"(byte) ({field.Name} ? 1 : 0)"];
            case true when field.TypeFullName == typeof(sbyte).FullName:
            case true when field.TypeFullName == typeof(byte).FullName:
                return [$"(byte) {field.Name}"];
            case true when field.TypeFullName == typeof(ushort).FullName:
            case true when field.TypeFullName == typeof(short).FullName:
            case true when field.TypeFullName == "System.Half":
                return
                [
                    $"(byte) ({field.Name} >> 0)",
                    $"(byte) ({field.Name} >> 8)"
                ];
            case true when field.TypeFullName == typeof(uint).FullName:
            case true when field.TypeFullName == typeof(int).FullName:
            case true when field.TypeFullName == typeof(float).FullName:
                return
                [
                    $"(byte) ({field.Name} >> 0)",
                    $"(byte) ({field.Name} >> 8)",
                    $"(byte) ({field.Name} >> 16)",
                    $"(byte) ({field.Name} >> 24)"
                ];
            case true when field.TypeFullName == typeof(ulong).FullName:
            case true when field.TypeFullName == typeof(long).FullName:
            case true when field.TypeFullName == typeof(double).FullName:
                return
                [
                    $"(byte) ({field.Name} >> 0)",
                    $"(byte) ({field.Name} >> 8)",
                    $"(byte) ({field.Name} >> 16)",
                    $"(byte) ({field.Name} >> 24)",
                    $"(byte) ({field.Name} >> 32)",
                    $"(byte) ({field.Name} >> 40)",
                    $"(byte) ({field.Name} >> 48)",
                    $"(byte) ({field.Name} >> 54)"
                ];
            default:
                throw new NotImplementedException($"Don't know how to get setter for {field.TypeFullName}");
        }
    }
}
