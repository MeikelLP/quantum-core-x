using System.ComponentModel.DataAnnotations;
using System.Reflection;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using QuantumCore.Networking;
using Xunit;

namespace Core.Networking.Generators.Tests;

public class SerializerGeneratorTests
{
    private static Compilation CreateCompilation(params string[] source)
        => CSharpCompilation.Create("compilation",
            source.Select(x => CSharpSyntaxTree.ParseText(x)).ToArray(),
            new[]
            {
                MetadataReference.CreateFromFile(typeof(SerializerGeneratorTests).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(PacketAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(StringLengthAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(AppDomain.CurrentDomain.GetAssemblies()
                    .First(x => x.GetName().Name == "System.Runtime").Location),
            },
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    [Fact]
    public void RecordStruct()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time, uint Delta);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Time,
                __Delta
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Time,
                    __Delta
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, uint Time, uint Delta);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Time,
                __Delta
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Time,
                    __Delta
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record_WithEnumAsByte()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

public enum HandshakeType : byte {
    
}

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, HandshakeType Type);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (System.Byte)this.Type;
        }

        public ushort GetSize()
        {
            return 6;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Type = (QuantumCore.Core.Packets.HandshakeType)bytes[(offset + 4)];
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Type
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Type = (QuantumCore.Core.Packets.HandshakeType) await stream.ReadEnumFromStreamAsync<byte>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Type
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record_WithEnumAsInt()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

public enum HandshakeType : int {
    
}

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, HandshakeType Type);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)((System.Int32)this.Type >> 0);
            bytes[offset + 6] = (byte)((System.Int32)this.Type >> 8);
            bytes[offset + 7] = (byte)((System.Int32)this.Type >> 16);
            bytes[offset + 8] = (byte)((System.Int32)this.Type >> 24);
        }

        public ushort GetSize()
        {
            return 9;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Type = (QuantumCore.Core.Packets.HandshakeType)System.BitConverter.ToInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Type
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Type = (QuantumCore.Core.Packets.HandshakeType) await stream.ReadEnumFromStreamAsync<int>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Type
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record_CustomOrder()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time) {
    [Field(0)]
    public uint Size => 15; 
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Size >> 0);
            bytes[offset + 2] = (byte)(this.Size >> 8);
            bytes[offset + 3] = (byte)(this.Size >> 16);
            bytes[offset + 4] = (byte)(this.Size >> 24);
            bytes[offset + 5] = (byte)(this.Handshake >> 0);
            bytes[offset + 6] = (byte)(this.Handshake >> 8);
            bytes[offset + 7] = (byte)(this.Handshake >> 16);
            bytes[offset + 8] = (byte)(this.Handshake >> 24);
            bytes[offset + 9] = (byte)(this.Time >> 0);
            bytes[offset + 10] = (byte)(this.Time >> 8);
            bytes[offset + 11] = (byte)(this.Time >> 16);
            bytes[offset + 12] = (byte)(this.Time >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Time
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Time
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record_WithDynamicString()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, string Message) {
    [Field(1)]
    public uint Size => (uint)Message.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (byte)(this.GetSize() >> 0);
            bytes[offset + 3] = (byte)(this.GetSize() >> 8);
            bytes[offset + 4] = (byte)(this.GetSize() >> 16);
            bytes[offset + 5] = (byte)(this.GetSize() >> 24);
            bytes.WriteString(this.Message, offset + 6, (int)this.Size + 1);
        }

        public ushort GetSize()
        {
            return (ushort)(6 + this.Message.Length + 1);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]) - 6;
            var __Message = System.Text.Encoding.ASCII.GetString(bytes[(offset + 5)..(System.Index)(offset + 5 + __Size)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type,
                __Message
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 6;
                var __Message = await stream.ReadStringFromStreamAsync(buffer, (int)__Size);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type,
                    __Message
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Record_WithDynamicByteArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, byte[] Flags) {
    [Field(1)]
    public uint Size => (uint)Flags.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (byte)(this.GetSize() >> 0);
            bytes[offset + 3] = (byte)(this.GetSize() >> 8);
            bytes[offset + 4] = (byte)(this.GetSize() >> 16);
            bytes[offset + 5] = (byte)(this.GetSize() >> 24);
            this.Flags.CopyTo(bytes, offset + 6);
        }

        public ushort GetSize()
        {
            return (ushort)(6 + this.Flags.Length);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]) - 7;
            var __Flags = bytes[(offset + 5)..(System.Index)(offset + 5 + __Size)].ToArray();
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type,
                __Flags
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 7;
                var __Flags = await stream.ReadByteArrayFromStreamAsync(buffer, (int)__Size);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type,
                    __Flags
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithFixedByteArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type)
{
    public byte[] Flags { get; init; } = new byte[4];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            this.Flags.CopyTo(bytes, offset + 2);
        }

        public ushort GetSize()
        {
            return 6;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Flags = bytes[(offset + 1)..(offset + 5)].ToArray();
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type
            )
            {
                Flags = __Flags
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Flags = await stream.ReadByteArrayFromStreamAsync(buffer, 4);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type
                )
                {
                    Flags = __Flags
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithFixedUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type)
{
    public ushort[] Flags { get; init; } = new ushort[2];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (byte)(this.Flags[0] >> 0);
            bytes[offset + 3] = (byte)(this.Flags[0] >> 8);
            bytes[offset + 4] = (byte)(this.Flags[1] >> 0);
            bytes[offset + 5] = (byte)(this.Flags[1] >> 8);
        }

        public ushort GetSize()
        {
            return 6;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Flags = new []
            {
                System.BitConverter.ToUInt16(bytes[(offset + 1)..(offset + 1 + 2)]),
                System.BitConverter.ToUInt16(bytes[(offset + 3)..(offset + 3 + 2)])
            };
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type
            )
            {
                Flags = __Flags
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Flags = new []
                {
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer)
                };
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type
                )
                {
                    Flags = __Flags
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithSubHeader()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x32, EDirection.Incoming)]
[SubPacket(0x01, 0)]
[PacketGenerator]
public partial class ShopBuy {
    public byte Count { get; set; }
    public byte Position { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class ShopBuy : IPacketSerializable
    {
        public static byte Header => 0x32;
        public static byte? SubHeader => 0x01;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x32;
            bytes[offset + 1] = 0x01;
            bytes[offset + 2] = this.Count;
            bytes[offset + 3] = this.Position;
        }

        public ushort GetSize()
        {
            return 4;
        }

        public static ShopBuy Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Count = bytes[(offset + 0)];
            var __Position = bytes[(offset + 1)];
            var obj = new QuantumCore.Core.Packets.ShopBuy
            {
                Count = __Count,
                Position = __Position
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Count = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Position = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.ShopBuy
                {
                    Count = __Count,
                    Position = __Position
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithSequence()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x02, EDirection.Incoming, Sequence = true)]
[PacketGenerator]
public partial class Attack
{
    [Field(0)]
    public byte AttackType { get; set; }
    [Field(1)]
    public uint Vid { get; set; }
    [Field(2, ArrayLength = 2)]
    public byte[] Unknown { get; set; } = new byte[2]{0,0};
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class Attack : IPacketSerializable
    {
        public static byte Header => 0x02;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => true;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x02;
            bytes[offset + 1] = this.AttackType;
            bytes[offset + 2] = (byte)(this.Vid >> 0);
            bytes[offset + 3] = (byte)(this.Vid >> 8);
            bytes[offset + 4] = (byte)(this.Vid >> 16);
            bytes[offset + 5] = (byte)(this.Vid >> 24);
            this.Unknown.CopyTo(bytes, offset + 6);
            bytes[offset + 8] = default;
        }

        public ushort GetSize()
        {
            return 9;
        }

        public static Attack Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __AttackType = bytes[(offset + 0)];
            var __Vid = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]);
            var __Unknown = bytes[(offset + 5)..(offset + 7)].ToArray();
            var obj = new QuantumCore.Core.Packets.Attack
            {
                AttackType = __AttackType,
                Vid = __Vid,
                Unknown = __Unknown
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __AttackType = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Vid = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Unknown = await stream.ReadByteArrayFromStreamAsync(buffer, 2);
                var obj = new QuantumCore.Core.Packets.Attack
                {
                    AttackType = __AttackType,
                    Vid = __Vid,
                    Unknown = __Unknown
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithDynamicStringAndSequence()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Game.Packets;

[Packet(0x03, EDirection.Incoming, Sequence = true)]
[PacketGenerator]
public partial class ChatIncoming
{
    [Field(0)] public ushort Size => (ushort)Message.Length;

    [Field(1)]
    public byte MessageType { get; set; }

    public string Message { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Game.Packets {

    public partial class ChatIncoming : IPacketSerializable
    {
        public static byte Header => 0x03;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => true;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x03;
            bytes[offset + 1] = (byte)(this.GetSize() >> 0);
            bytes[offset + 2] = (byte)(this.GetSize() >> 8);
            bytes[offset + 3] = this.MessageType;
            bytes.WriteString(this.Message, offset + 4, (int)this.Size + 1);
            bytes[offset + 4 + this.Message.Length] = default;
        }

        public ushort GetSize()
        {
            return (ushort)(5 + this.Message.Length + 1);
        }

        public static ChatIncoming Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Size = System.BitConverter.ToUInt16(bytes[(offset + 0)..(offset + 0 + 2)]) - 4;
            var __MessageType = bytes[(offset + 2)];
            var __Message = System.Text.Encoding.ASCII.GetString(bytes[(offset + 3)..(System.Index)(offset + 3 + __Size)]);
            var obj = new QuantumCore.Game.Packets.ChatIncoming
            {
                MessageType = __MessageType,
                Message = __Message
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Size = await stream.ReadValueFromStreamAsync<UInt16>(buffer) - 4;
                var __MessageType = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Message = await stream.ReadStringFromStreamAsync(buffer, (int)__Size);
                var obj = new QuantumCore.Game.Packets.ChatIncoming
                {
                    MessageType = __MessageType,
                    Message = __Message
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_NoFields()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x0B, EDirection.Outgoing)]
[PacketGenerator]
public partial class DeleteCharacterFail
{
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class DeleteCharacterFail : IPacketSerializable
    {
        public static byte Header => 0x0B;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x0B;
        }

        public ushort GetSize()
        {
            return 1;
        }

        public static DeleteCharacterFail Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var obj = new QuantumCore.Core.Packets.DeleteCharacterFail
            {
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var obj = new QuantumCore.Core.Packets.DeleteCharacterFail
                {
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Invalid_Fields_Throws()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x32, EDirection.Incoming, Sequence = true)]
[SubPacket(0x01, 0)]
[PacketGenerator]
public partial class ShopBuy
{
    [Field(1)]
    public byte Count { get; set; }
    [Field(2)]
    public byte Position { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out _,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().Contain("Field configuration for type ShopBuy is invalid");
        diagnostics[0].Id.Should().BeEquivalentTo("QCX-G000005");
    }
    
    [Fact]
    public void Record_WithFixedStringArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake()
{
    [Field(0, Length = 13)]
    public string[] Names { get; init; } = new string[2];
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes.WriteString(this.Names[0], offset + 1, (int)13);
            bytes.WriteString(this.Names[1], offset + 14, (int)13);
        }

        public ushort GetSize()
        {
            return 27;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Names = new []
            {
                System.Text.Encoding.ASCII.GetString(bytes[(offset + 0)..(offset + 0 + 13)]),
                System.Text.Encoding.ASCII.GetString(bytes[(offset + 13)..(offset + 13 + 13)])
            };
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Names = __Names
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Names = new []
                {
                    await stream.ReadStringFromStreamAsync(buffer, (int)13),
                    await stream.ReadStringFromStreamAsync(buffer, (int)13)
                };
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Names = __Names
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }
    
    [Fact]
    public void Record_WithDynamicUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, ushort[] Flags)
{
    [Field(1)]
    public uint Size => (uint)Flags.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (byte)(this.GetSize() >> 0);
            bytes[offset + 3] = (byte)(this.GetSize() >> 8);
            bytes[offset + 4] = (byte)(this.GetSize() >> 16);
            bytes[offset + 5] = (byte)(this.GetSize() >> 24);
            for (var i = 0; i < this.Flags.Length; i++)
            {
                bytes[offset + 6 + i * 2] = (byte)(this.Flags[i] >> 0);
                bytes[offset + 7 + i * 2] = (byte)(this.Flags[i] >> 8);
            }
        }

        public ushort GetSize()
        {
            return (ushort)(6 + this.Flags.Length * 2);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]) - 8;
            var __Flags = new System.UInt16[__Size];
            for (var i = 0; i < __Size; i++)
            {
                __Flags[i] = System.BitConverter.ToUInt16(bytes[(offset + 5 + 2 * i)..(offset + 5 + 2 * i + 2)]);
            }
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type,
                __Flags
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 8;
                var __Flags = new System.UInt16[__Size];
                for (var i = 0; i < __Size; i++)
                {
                    __Flags[i] = await stream.ReadValueFromStreamAsync<UInt16>(buffer);
                }
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type,
                    __Flags
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }
    
    [Fact]
    public void SizeAfterArray_Error()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, ushort[] Flags)
{
    public uint Size => Flags.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out _,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().BeEquivalentTo("Size fields must be have a position before their array");
    }

    [Fact]
    public void Record_WithDynamic_FieldAfter()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, string Message, byte Location) {
    [Field(1)]
    public uint Size => (uint)this.Message.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (byte)(this.GetSize() >> 0);
            bytes[offset + 3] = (byte)(this.GetSize() >> 8);
            bytes[offset + 4] = (byte)(this.GetSize() >> 16);
            bytes[offset + 5] = (byte)(this.GetSize() >> 24);
            bytes.WriteString(this.Message, offset + 6, (int)this.Size + 1);
            bytes[offset + 6 + this.Message.Length] = this.Location;
        }

        public ushort GetSize()
        {
            return (ushort)(7 + this.Message.Length + 1);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]) - 7;
            var __Message = System.Text.Encoding.ASCII.GetString(bytes[(offset + 5)..(System.Index)(offset + 5 + __Size)]);
            var __Location = bytes[(System.Index)(offset + 5 + __Size)];
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type,
                __Message,
                __Location
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 7;
                var __Message = await stream.ReadStringFromStreamAsync(buffer, (int)__Size);
                var __Location = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type,
                    __Message,
                    __Location
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void MultipleTypesPerFile()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(uint Handshake, uint Time, uint Delta);

[Packet(0xfd, EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCPhase(byte Phase);
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(2);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(2);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources.First(x => x.SourceText.ToString().Contains("GCHandshake"))
            .SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Time,
                __Delta
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Time,
                    __Delta
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
        runResult.Results[0].GeneratedSources.First(x => x.SourceText.ToString().Contains("GCPhase"))
            .SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCPhase : IPacketSerializable
    {
        public static byte Header => 0xfd;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xfd;
            bytes[offset + 1] = this.Phase;
        }

        public ushort GetSize()
        {
            return 2;
        }

        public static GCPhase Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Phase = bytes[(offset + 0)];
            var obj = new QuantumCore.Core.Packets.GCPhase
            (
                __Phase
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Phase = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.GCPhase
                (
                    __Phase
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial struct GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData Sub { get; set; }
}

public class SomeData {
    public uint SomeSubData { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
            bytes[offset + 13] = (byte)(this.Sub.SomeSubData >> 0);
            bytes[offset + 14] = (byte)(this.Sub.SomeSubData >> 8);
            bytes[offset + 15] = (byte)(this.Sub.SomeSubData >> 16);
            bytes[offset + 16] = (byte)(this.Sub.SomeSubData >> 24);
        }

        public ushort GetSize()
        {
            return 17;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var __Sub = new QuantumCore.Core.Packets.SomeData
            {
                SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)])
            };
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta,
                Sub = __Sub
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Sub = new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                };
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta,
                    Sub = __Sub
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void RecordWithMembers()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record GCHandshake(uint Handshake, uint Time) {
    public uint Delta { get; init; }
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Handshake,
                __Time
            )
            {
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Handshake,
                    __Time
                )
                {
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithFixedArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData[] Subs { get; set; } = new SomeData[4];
}

public class SomeData {
    public uint SomeSubData { get; set; }
    public uint SomeSubData2 { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.Delta >> 0);
            bytes[offset + 10] = (byte)(this.Delta >> 8);
            bytes[offset + 11] = (byte)(this.Delta >> 16);
            bytes[offset + 12] = (byte)(this.Delta >> 24);
            bytes[offset + 13] = (byte)(this.Subs[0].SomeSubData >> 0);
            bytes[offset + 14] = (byte)(this.Subs[0].SomeSubData >> 8);
            bytes[offset + 15] = (byte)(this.Subs[0].SomeSubData >> 16);
            bytes[offset + 16] = (byte)(this.Subs[0].SomeSubData >> 24);
            bytes[offset + 17] = (byte)(this.Subs[0].SomeSubData2 >> 0);
            bytes[offset + 18] = (byte)(this.Subs[0].SomeSubData2 >> 8);
            bytes[offset + 19] = (byte)(this.Subs[0].SomeSubData2 >> 16);
            bytes[offset + 20] = (byte)(this.Subs[0].SomeSubData2 >> 24);
            bytes[offset + 21] = (byte)(this.Subs[1].SomeSubData >> 0);
            bytes[offset + 22] = (byte)(this.Subs[1].SomeSubData >> 8);
            bytes[offset + 23] = (byte)(this.Subs[1].SomeSubData >> 16);
            bytes[offset + 24] = (byte)(this.Subs[1].SomeSubData >> 24);
            bytes[offset + 25] = (byte)(this.Subs[1].SomeSubData2 >> 0);
            bytes[offset + 26] = (byte)(this.Subs[1].SomeSubData2 >> 8);
            bytes[offset + 27] = (byte)(this.Subs[1].SomeSubData2 >> 16);
            bytes[offset + 28] = (byte)(this.Subs[1].SomeSubData2 >> 24);
            bytes[offset + 29] = (byte)(this.Subs[2].SomeSubData >> 0);
            bytes[offset + 30] = (byte)(this.Subs[2].SomeSubData >> 8);
            bytes[offset + 31] = (byte)(this.Subs[2].SomeSubData >> 16);
            bytes[offset + 32] = (byte)(this.Subs[2].SomeSubData >> 24);
            bytes[offset + 33] = (byte)(this.Subs[2].SomeSubData2 >> 0);
            bytes[offset + 34] = (byte)(this.Subs[2].SomeSubData2 >> 8);
            bytes[offset + 35] = (byte)(this.Subs[2].SomeSubData2 >> 16);
            bytes[offset + 36] = (byte)(this.Subs[2].SomeSubData2 >> 24);
            bytes[offset + 37] = (byte)(this.Subs[3].SomeSubData >> 0);
            bytes[offset + 38] = (byte)(this.Subs[3].SomeSubData >> 8);
            bytes[offset + 39] = (byte)(this.Subs[3].SomeSubData >> 16);
            bytes[offset + 40] = (byte)(this.Subs[3].SomeSubData >> 24);
            bytes[offset + 41] = (byte)(this.Subs[3].SomeSubData2 >> 0);
            bytes[offset + 42] = (byte)(this.Subs[3].SomeSubData2 >> 8);
            bytes[offset + 43] = (byte)(this.Subs[3].SomeSubData2 >> 16);
            bytes[offset + 44] = (byte)(this.Subs[3].SomeSubData2 >> 24);
        }

        public ushort GetSize()
        {
            return 45;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var __Subs = new []
            {
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 16)..(offset + 16 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 20)..(offset + 20 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 24)..(offset + 24 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 28)..(offset + 28 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 32)..(offset + 32 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 36)..(offset + 36 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 40)..(offset + 40 + 4)])
                }
            };
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta,
                Subs = __Subs
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Subs = new []
                {
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    }
                };
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta,
                    Subs = __Subs
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_WithDynamicArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Size => (uint)Subs.Length;
    public SomeData[] Subs { get; set; }
    public uint Delta { get; set; }
}

public class SomeData {
    public uint SomeSubData { get; set; }
    public byte SubByte { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (byte)(this.Handshake >> 0);
            bytes[offset + 2] = (byte)(this.Handshake >> 8);
            bytes[offset + 3] = (byte)(this.Handshake >> 16);
            bytes[offset + 4] = (byte)(this.Handshake >> 24);
            bytes[offset + 5] = (byte)(this.Time >> 0);
            bytes[offset + 6] = (byte)(this.Time >> 8);
            bytes[offset + 7] = (byte)(this.Time >> 16);
            bytes[offset + 8] = (byte)(this.Time >> 24);
            bytes[offset + 9] = (byte)(this.GetSize() >> 0);
            bytes[offset + 10] = (byte)(this.GetSize() >> 8);
            bytes[offset + 11] = (byte)(this.GetSize() >> 16);
            bytes[offset + 12] = (byte)(this.GetSize() >> 24);
            for (var i = 0; i < this.Subs.Length; i++)
            {
                bytes[offset + 13 + i * 5] = (byte)(this.Subs[i].SomeSubData >> 0);
                bytes[offset + 14 + i * 5] = (byte)(this.Subs[i].SomeSubData >> 8);
                bytes[offset + 15 + i * 5] = (byte)(this.Subs[i].SomeSubData >> 16);
                bytes[offset + 16 + i * 5] = (byte)(this.Subs[i].SomeSubData >> 24);
                bytes[offset + 17 + i * 5] = this.Subs[i].SubByte;
            }
            bytes[offset + 13 + this.Subs.Length * 5] = (byte)(this.Delta >> 0);
            bytes[offset + 14 + this.Subs.Length * 5] = (byte)(this.Delta >> 8);
            bytes[offset + 15 + this.Subs.Length * 5] = (byte)(this.Delta >> 16);
            bytes[offset + 16 + this.Subs.Length * 5] = (byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return (ushort)(17 + this.Subs.Length * 5);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]) - 22;
            var __Subs = new QuantumCore.Core.Packets.SomeData[__Size];
            for (var i = 0; i < __Size; i++)
            {
                __Subs[i].SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12 + 5 * i)..(offset + 12 + 5 * i + 4)]);
                __Subs[i].SubByte = bytes[(offset + 16 + 5 * i)];
            }
            var __Delta = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 17 + __Size)..(System.Index)(offset + 17 + __Size + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Subs = __Subs,
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 22;
                var __Subs = new QuantumCore.Core.Packets.SomeData[__Size];
                for (var i = 0; i < __Size; i++)
                {
                    __Subs[i].SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                    __Subs[i].SubByte = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                }
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Subs = __Subs,
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Class_DataAfterFixedUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0x88, EDirection.Incoming)]
[PacketGenerator]
public partial class CharacterInfo {
    [Field(0)]
    public uint Vid { get; set; }
    [Field(1, Length = 25)]
    public string Name { get; set; }
    [Field(2)]
    public ushort[] Parts { get; set; } = new ushort[4];
    [Field(3)]
    public byte Empire { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class CharacterInfo : IPacketSerializable
    {
        public static byte Header => 0x88;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x88;
            bytes[offset + 1] = (byte)(this.Vid >> 0);
            bytes[offset + 2] = (byte)(this.Vid >> 8);
            bytes[offset + 3] = (byte)(this.Vid >> 16);
            bytes[offset + 4] = (byte)(this.Vid >> 24);
            bytes.WriteString(this.Name, offset + 5, (int)25);
            bytes[offset + 30] = (byte)(this.Parts[0] >> 0);
            bytes[offset + 31] = (byte)(this.Parts[0] >> 8);
            bytes[offset + 32] = (byte)(this.Parts[1] >> 0);
            bytes[offset + 33] = (byte)(this.Parts[1] >> 8);
            bytes[offset + 34] = (byte)(this.Parts[2] >> 0);
            bytes[offset + 35] = (byte)(this.Parts[2] >> 8);
            bytes[offset + 36] = (byte)(this.Parts[3] >> 0);
            bytes[offset + 37] = (byte)(this.Parts[3] >> 8);
            bytes[offset + 38] = this.Empire;
        }

        public ushort GetSize()
        {
            return 39;
        }

        public static CharacterInfo Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Vid = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Name = System.Text.Encoding.ASCII.GetString(bytes[(offset + 4)..(offset + 4 + 25)]);
            var __Parts = new []
            {
                System.BitConverter.ToUInt16(bytes[(offset + 29)..(offset + 29 + 2)]),
                System.BitConverter.ToUInt16(bytes[(offset + 31)..(offset + 31 + 2)]),
                System.BitConverter.ToUInt16(bytes[(offset + 33)..(offset + 33 + 2)]),
                System.BitConverter.ToUInt16(bytes[(offset + 35)..(offset + 35 + 2)])
            };
            var __Empire = bytes[(offset + 37)];
            var obj = new QuantumCore.Core.Packets.CharacterInfo
            {
                Vid = __Vid,
                Name = __Name,
                Parts = __Parts,
                Empire = __Empire
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Vid = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Name = await stream.ReadStringFromStreamAsync(buffer, (int)25);
                var __Parts = new []
                {
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                    await stream.ReadValueFromStreamAsync<UInt16>(buffer)
                };
                var __Empire = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.CharacterInfo
                {
                    Vid = __Vid,
                    Name = __Name,
                    Parts = __Parts,
                    Empire = __Empire
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Invalid_PositionDoesNotExist()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Auth.Packets
{
    [Packet(0x07, EDirection.Outgoing)]
    [PacketGenerator]
    public partial class LoginFailed
    {
        [Field(1, Length = 9)]
        public string Status { get; set; }
    }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().Be("Field cannot have a higher number (1) than actual fields count 1");
    }

    [Fact]
    public void MultipleFiles()
    {
        const string file1 = @"
using QuantumCore.Networking;

namespace QuantumCore.Game.Packets;

[Packet(0x20, EDirection.Outgoing)]
[PacketGenerator]
public partial record struct Characters ()
{
    public Character[] CharacterList { get; set; } = new Character[2];
}";
        const string file2 = @"
namespace QuantumCore.Game.Packets;

public record Character(uint Id);";
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new PacketSerializerGenerator());
        var inputCompilation = CreateCompilation(file1, file2);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results.Should().HaveCount(1);
        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Game.Packets {

    public partial record struct Characters : IPacketSerializable
    {
        public static byte Header => 0x20;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x20;
            bytes[offset + 1] = (byte)(this.CharacterList[0].Id >> 0);
            bytes[offset + 2] = (byte)(this.CharacterList[0].Id >> 8);
            bytes[offset + 3] = (byte)(this.CharacterList[0].Id >> 16);
            bytes[offset + 4] = (byte)(this.CharacterList[0].Id >> 24);
            bytes[offset + 5] = (byte)(this.CharacterList[1].Id >> 0);
            bytes[offset + 6] = (byte)(this.CharacterList[1].Id >> 8);
            bytes[offset + 7] = (byte)(this.CharacterList[1].Id >> 16);
            bytes[offset + 8] = (byte)(this.CharacterList[1].Id >> 24);
        }

        public ushort GetSize()
        {
            return 9;
        }

        public static Characters Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __CharacterList = new []
            {
                new QuantumCore.Game.Packets.Character
                (
                    System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)])
                ),
                new QuantumCore.Game.Packets.Character
                (
                    System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)])
                )
            };
            var obj = new QuantumCore.Game.Packets.Characters
            {
                CharacterList = __CharacterList
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __CharacterList = new []
                {
                    new QuantumCore.Game.Packets.Character
                    (
                        await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    ),
                    new QuantumCore.Game.Packets.Character
                    (
                        await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    )
                };
                var obj = new QuantumCore.Game.Packets.Characters
                {
                    CharacterList = __CharacterList
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");

    }

    [Fact]
    public void ReadonlyRefStruct()
    {
        Assert.True(true, "ref structs cannot implement interfaces");
    }
}